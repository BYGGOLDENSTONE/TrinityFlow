
You are Claude Code, an AI assistant for generating Unreal Engine code. I have a project in Unreal Engine 5.5, and you have access to my project folder, including the file "GDD.txt" which contains the full Game Design Document for my game "TrinityFlow". Read "GDD.txt" carefully and implement the entire game as described in it, using only C++ for all logic, components, and systems. Do not use the Gameplay Ability System (GAS), Blueprints, or any UMG Widgets—everything must be in pure C++ for quick testing and prototyping.

### Project Structure and File Organization
Follow Unreal Engine's standard file system rules:
- Place all .h files in the Public subfolder of their respective module folders.
- Place all .cpp files in the Private subfolder of their respective module folders.
- Organize code files into logical folders within the Source directory, such as:
  - Core: For base classes, enums, structs, damage calculations, and shared utilities (e.g., damage types, tags, states).
  - Player: For player character, controller, weapons (Override Katana and Divine Anchor), and related components.
  - Enemy: For all enemy types (Standard, Tank, Shielded Tank, Phase, Shielded Tank Robot) and AI behaviors.
  - Combat: For combat systems, abilities, defensive actions, and states.
  - HUD: For the custom C++-based HUD implementation.

Create any necessary Build.cs files or module dependencies if needed, but keep the project minimal.

### Core Implementation Guidelines
- Use a component-based architecture: All entities (player, enemies) should inherit from AActor or APawn as appropriate, with UActorComponents for modular features like health resources, tags, states, weapons, and abilities.
- Implement all resources (health, defencepoint, attackpoint), damage types (Physical, Soul), tags (shielded, armored, ghost, mechanical, havesoul), and states (vulnerable, combat, non-combat, marked) as described in GDD.txt.
- Damage calculations must match exactly: Physical as attackpoint * (100 - defencepoint)%, Soul as attackpoint * 2, with Soul bypassing defenses and shields.
- Gameplay loop: Player can switch weapons mid-combat. Space key switches contextually (jump in non-combat, defensive ability in combat). Combat starts when enemies see the player.
- For prototyping: Use simple growing trace lines (e.g., via DrawDebugLine) from enemy to player for attack casting visuals instead of animations. Set up a basic test level (e.g., an arena map) with spawn points for enemies and player. All enemies have 300 range and 1.5s attack cooldown for testing.
- Input: Bind keys like LMB for basic attacks, Q/E for weapon abilities, Space for defensive/jump.
- No multiplayer or advanced features—single-player only for now.

### Weapons and Abilities
- Implement Override Katana and Divine Anchor as switchable weapons, each with their basic attack (Slash/Smash) and abilities (Echoes of Data, Code Break, Gravity Pull, Holy Gravity).
- Defensive abilities (Scripted Dodge, Order): Implement timing windows (1.5s enemy cast; moderate 0-0.75s, perfect 0.75-1.5s). Perfect Dodge resets Code Break cooldown; Perfect Order strips shield (full removal of shielded tag for now) or 25% armor if no shield.
- Echoes of Data: Mark enemy for 5s; when damaging other enemies, echo 75% of post-defense damage as Soul (30% for AoE, summed). If marked dies first, effect ends.
- All ranges, cooldowns, effects (e.g., knockback, vulnerable in air) as in GDD.txt.

### Player and Enemies
- Player: APawn or ACharacter with tags (havesoul, armored), resources (200 health, 20 attack/defence), and weapon switching.
- Enemies: Each as separate classes inheriting from a base AEnemy, with specific tags, resources, and abilities. Use simple AI (e.g., Behavior Trees or basic tick logic) to attack within 300 range on 1.5s cooldown.
- Detection: Use line traces or overlap spheres for enemy sight to trigger combat state.

### HUD Implementation
Implement a detailed C++-based HUD using UCanvas or direct rendering in the player's viewport (no widgets). The HUD must be always visible and show:
- Player's health bar (horizontal bar at bottom, scaled by current/max health).
- A central dot (crosshair) in the middle of the screen for targeting.
- When the dot (via line trace from camera) hits a character (player or enemy), display detailed info overlay near the dot or in a corner:
  - Target's health bar and value (e.g., "Health: 150/200").
  - Other resources: Defencepoint, Attackpoint.
  - Tags (e.g., "Tags: havesoul, armored, shielded").
  - States (e.g., "States: combat, marked").
  - If marked, show remaining duration.
- Also display globally on HUD:
  - Player's full resources (health, defencepoint, attackpoint).
  - Current weapon and ability cooldowns (e.g., icons or text timers for Q/E).
  - Combat state indicator (e.g., "In Combat").
  - For testing: List nearby enemies' types and states.
Use DrawText, DrawLine, DrawTexture (for bars/dots) in PostRender or a custom HUD class overriding APlayerController or AHUD.

### Output Format
Generate all necessary code files one by one, showing the full path (e.g., Source/Core/Public/DamageTypes.h) and complete code contents. After all files, provide instructions on how to set up the project (e.g., create a blank C++ project, add these files, compile, create a test map with player and enemy spawners).

Implement everything faithfully from "GDD.txt"—do not add extra features unless for basic functionality (e.g., camera, movement). Focus on quick testing in a simple arena.

Start generating the code now.

--- 
